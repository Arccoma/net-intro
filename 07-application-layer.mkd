Application Layer
=================

We are now a the top layer of our four layer model that governs the design of
our current Internet.   The Transport layer makes use of the Internetwork and
Link layers to reliably deliver a message or stream of data across the
Internet.   The application layer is both the source and destination of these
messages.   The simplest and most common examples of networked applications
would be a web browser or a mail reading application.

It is important to understand that for a networked application to function
there are two required parts of each application.   The architecture for a
networked application is called "client-server".   The server portion of
the application runs
somewhere in the Internet and has the information that you want to view or
interact with.  The client portion of the application makes
connections to the server
application, and retrieves information and shows it to the user.

In order for you to brows a web address like www.khanacademy.org, you have a
web application running on your computer.  When you type an address into your
web browser, it makes a connection to the appropriate web server, retrieves
pages for you to view and then shows you the pages.

These applications make use of the transport layer on each of their computers
to exchange data.

![Applications and the Transport Layer](images/application-transport)

The web browser on your computer makes a request to connect to
www.khanacademy.org.  Your computer looks up the domain name to find the
corresponding IP address for the server and makes a transport connection to
that IP address and then begins to request data from the server over that
network connection.  When the data is received it shows it to you.   Sometimes
your web browsers shows a small animated icon to let you know when the browser
is retrieving data across the network.

On the other end of the connection is another program (Application) called a
"web server".  The web server program is always up and waiting for incoming
connections.  So when you want to see a web page, you are connecting to a
server application that is already running and waiting for your connection.

In a sense, the Transport, Internetwork, and Link layers along with the Domain
Name System are like a phone network for networked applications.
They "dial up" different server
applications on the network and have "conversations" with those applications to
exchange data.

Application Layer Protocols
---------------------------

Just like people talking on telephones, each pair (client and server) of
applications need a set of rules that govern the conversation.   In most
cultures when your phone rings and you pick up the phone you say 'Hello'.
Normally the person who made the call (the client person) is silent until the
person who picked up the phone (the server person) says "Hello".  If you have
ever called someone who does not follow this simple rule, it can be quite
confusing.  You probably would assume that the phone call was not working, hang
up and retry the call.

This set of rules that govern how we "talk" is called a "protocol".  The
definition of the word protocol is "A protocol is a rule which describes how an
activity should be performed, especially in the field of diplomacy".  There is
this idea that in formal situations, we should behave according to a precise
set of rules.  We use this word to describe networked applications, because
without precise rules, applications have no way to establish and have a
conversation.   Computers like precision.

There are many networked applications that are found in the Application Layer
and it is important that each networked application have a well-documented
protocol so that all servers and clients can interoperate.  Some of these
protocols are very intricate and complex.   The protocol that describes how a
web browser communicated with a web server is described in a number of large
documents starting with this document:

[https://tools.ietf.org/html/rfc7230](https://tools.ietf.org/html/rfc7230)

The formal name of the protocol between web clients and web servers is the
"HyperText Transport Protocol" or "HTTP" for short.  When you put "http:" or
"https:" on the beginning of a URL when you type it into the browser, you are
indicating that you would like to retrieve a document using the HTTP protocol.

If you were to read the above document, and go to section 5.3.2 on page 41, you
find the exact text of what a web client is supposed to sent to a web server:

    GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1

One of the reasons that the HTTP is so successful if that it is relatively
simple compared to most client-server protocols.   Even though the basic use of
HTTP is relatively simple, there is a lot of detail that allows web clients and
servers communicate efficiently and transfer a wide range of information and
data.   There are a total of six documents that describe the HTTP protocol with
a total of 305 pages.   That might seem like a lot of detail, but the key in
designing protocols is to thing through all possible uses of the protocol and
describe each scenario very carefully.

Exploring the HTTP Protocol
---------------------------

In this section we manually exercise the HTTP protocol by pretending to be a
web browser and sending HTTP commands to the web browser to retrieve data.  To
play with the HTTP protocol, we will use one of the earliest applications ever
built.

The "telnet" application was first developed in 1968 and was developed
according to one of the earliest standards for the Internet:

[https://tools.ietf.org/html/rfc15](https://tools.ietf.org/html/rfc15)

This standard is only five pages long and at this point, you probably can
easily read most of what is in the document.   The telnet command is so old
that it is effectively a "dinosaur" as it comes from "pre-historic" times in
terms of the age of the Internet.  The Internet was created in 1985 and the
precursor to the Internet called the ARPANET was brought up in 1969.  Telnet
was designed and built even before the first network was in production.

Interestingly the telnet comment is still present in most modern operating
systems.  You can access telnet in the terminal (command line) in Macintosh and
Linux.  The telnet command was present in Windows-95 through Windows-XP but is
not present on later versions of Windows.  If you have a later version of
Windows, you can download and install a telnet client so you can do the
examples in this section.

The telnet command is exceedingly simple as an application.  You run telnet
from the command line (or terminal) and type the following command:

    telnet www.dr-chuck.com 80

The first parameter is a domain name (an IP address would work here as well)
and a port to connect to on that host.   We use the port to indicate which
application server we would like to connect to.  Port 80 is where we typically
expect to find a HTTP (web) server application on a host.  If there is no web
server listening on port 80, our connection will time out and fail.  But if
there is a web server, we will be connected to that web server and whatever we
type on our keyboard will be sent directly to the server.   At this point, we
need to know the HTTP protocol and type the commands precisely as expected.
If we don't know the protocol, the web server will not be too friendly.  Here
is an example of things not going well.   What you type is in bold:

    telnet www.dr-chuck.com 80
    Trying 198.251.66.43...
    Connected to www.dr-chuck.com.
    Escape character is '^]'.
    HELP
    <!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
    <html><head>
    <title>501 Method Not Implemented</title>
    ...
    </body></html>
    Connection closed by foreign host.

We type the telnet command in the terminal requesting to connect to port 80
(the web server) on the host www.dr-chuck.com.  You can see as our transport
layer is looking up the domain name and finding that the actual address is
"198.251.66.43" and then making a successful connection to that server.  Once
we are connected, the server simply waits for us to type a command followed by
the enter or return key.  Since we don't know the protocol, we simply type
"HELP" and enter.  The server is not pleased, and gives us an error message and
then closes the connection.  We do not get a second chance - if we do not know
the protocol - the web server does not want to talk to us.

But lets go back and read section 5.3.2 of the RFC-7230 document and try again
to request a document using the correct syntax:

    telnet www.dr-chuck.com 80
    Trying 198.251.66.43...
    Connected to www.dr-chuck.com.
    Escape character is '^]'.
    GET http://www.dr-chuck.com/page1.htm HTTP/1.1
    Host: www.dr-chuck.com

    HTTP/1.1 200 OK
    Last-Modified: Sun, 19 Jan 2014 14:25:43 GMT
    Content-Length: 131
    Content-Type: text/html

    <h1>The First Page</h1>
    <p>
    If you like, you can switch to the
    <a href="http://www.dr-chuck.com/page2.htm">
    Second Page</a>.
    </p>
    Connection closed by foreign host.

We make the connection to the web browser again using telnet, then we send a
GET command that indicates which document we want to retrieve followed by a
Host: header indicating which host to retrieve the document from and then we
send a blank line by pressing "return" or "enter" to indicate we are done with
our request.

Given that we have send the proper request, the host responds first with a
series of headers describing the document followed by a blank line than then
sends the actual document.  This is a Hypertext Markup Language (HTML) document
so it is marked up with tags like \<h1\> and \<p\>.   When your browser receives
the document in HTML format, it looks at the markup in the document and
presents you a formatted version of the document.

The IMAP Protocol for Retrieving Mail
-------------------------------------

The HTTP protocol is only one of many client-server application protocols used on the
Internet.  Another common protocol is used so that a mail application running
on your computer can retrieve mail from a central server.   Since your personal
computer might not be turned on at all time, when mail is sent to you it is
sent to a server and stored on that server until you turn on your computer and
retrieve any new email.

Like many application standards, the Internet Message Access Protocol (IMAP) is
described in a series of Request For Comment (RFC) documents starting with this
RFC:

    https://tools.ietf.org/html/rfc3501

IMAP is a more complicated protocol than the web protocol so we won't be able
to use the telnet command to fake the protocol.  But if you were going to
develop a mail reading application, you could carefully read this document and
develop code to have a successful conversation with a standards-complaint IMAP
server.  Here is a simple example from section 6.3.1 of the above document
showing what the client sends (C:) and how the server (S:) responds:

    C: A142 SELECT INBOX
    S: * 172 EXISTS
    S: * 1 RECENT
    S: * OK [UNSEEN 12] Message 12 is first unseen
    S: * OK [UIDVALIDITY 3857529045] UIDs valid
    S: * OK [UIDNEXT 4392] Predicted next UID
    S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
    S: * OK [PERMANENTFLAGS (\Deleted \Seen \*)] Limited
    S: A142 OK [READ-WRITE] SELECT completed

The messages that are sent by the client and server are not designed to be
viewed by an end-user so they are not particularly talkative.   These messages
are precisely formatted and are sent in a precise order so that they can be
generated and read by networked computer applications on each end of the
connection.

Flow Control
------------

When we looked at the transport layer, we talked about the "window size" which
was the amount of data that the transport layer on sending computer will send
before pausing to wait for an acknowledgement.

![Buffering in the Transport Layer](images/transport-buffer)

In this figure, we see a message, broken into packets, some of the packets have been sent and
acknowledged.  Six packets have been send but not acknowledged yet and the
sending transport layer has reached the limit of the transmit window so it is
pausing until it receives an acknowledgement from the receiving transport
layer.  The receiving transmit layer has received three packets, one of which
is out of order.

When we were looking at this figure from the point of view of the transport
layer, we ignored where the packets to be sent were coming from and where the
packets are going to in the receiving computer.

Now that we are looking at the Application layer, we can add the two
applications that are the source and the destination of the stream of data.

Lets assume the Web Browser has made a transport connection to the Web Server
and has started downloading an image file from the Web Server.  The Web Server
has opened the image file and is sending the data from the file to its
Transport Layer as quickly as possible.  But the transport layer must follow
the rules of window size and so it can only send a certain amount of data.
When the window size fills up, the web server is paused until the transport
layer on the destination computer has started to receive and acknowledge
packets.

As the Transport layer on the destination computer starts to receive packets,
reconstruct the stream of data and acknowledge packets it delivers the
reconstructed stream of packets to the web browser application of display on
the user's screen.  Sometimes on a slow connection, you can see your browser
"paint" pictures as the data is downloaded.  On a  fast connection the data
comes so quickly that the pictures appear instantaneously.

If we redraw the above picture of packets in the Transport Layer, adding both
of the application layers where the packets are in the middle of an image, it
looks as follows:

![Buffering in the Application and Transport Layers](images/application-transport-buffer)

The Web Server is reading the image file and sending it as a stream to the web
browser as quickly as it can send the data.  The source transport layer has
broken the stream into packets and used IP to send the packets to the
destination computer.  The transport layer has sent six packets and has stopped
sending because it has reached its window size and paused the web server.
Three of those six packets have made it to the transport layer on the
destination computer and three of the packets are still making their way
through the Internet.  As the destination transport layer pieces the stream
back together, it both sends an acknowledgement and delivers the data to the
receiving application (i.e. web browser).  The web browser is reconstructing
the image and displaying it on the user's display.

A key thing to notice in this picture is that the transport layers do not keep
the packets for the entire file.  The transport layer only sends retains
packets that are "in-transit" and unacknowledged.  Once packets are
acknowledged and delivered to the destination application, there is no reason
for either the source nor destination transport layers to hold on to the
packets.

When the acknowledgment flows back from the destination computer to the source
computer, the transport on the source computer un-pauses the web server
application and the web server continues to read data from the file and send it
to the source transport layer.

This ability to start and stop the sending application to make sure we send
data as quickly as possible without sending data so fast to clog up the
internet is called "flow control". The applications are not responsible for
flow control - they just try to send or receive data as quickly as possible and
the two transport layers start and stop the applications as needed based on the
speed and reliability of the network.

Once again, we see a higher level layer that makes use of the capabilities of
the lower layer in the model to make its job much simpler.

Summary
-------

The entire purpose of the lower three layers (Transport, Internetwork, and
Link) is to make it so that Applications running in the Application layer can
focus on solving the application problem that needs to be solved and leave
virtually all of the extreme complexity of moving data across a network to be
handled by the lower layers of the network model.

Because this approach makes it so simple to build networked applications, we
have seen a wide range of networked applications from web browsers, mail
applications, networked video games, network-based telephony applications and
many others.  And what is even more exciting is that it is easy to experiment
and build whole new types of networked applications that solve problems that
have no yet been imagined.




*Draft - Copyright All Rights Reserved - Charles R. Severance.
Please do not reproduce or redistribute.*
