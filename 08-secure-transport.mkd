Secure Transport Layer
======================

\index{Transport Layer}
\index{Layer!Transport}
In the early days of the Internet, since the networks were small and all
of the (<100) routers were in secure locations, it was not all that
important to encrypt network traffic while it was crossing the network.  As
long as each computer connected to the Internet protected itself from unwanted
incoming connections, it was felt that there was no need to encrypt network
traffic.  So the Link, Internetwork, and Transport layers were not designed with
encryption in mind.  They were focused on the efficient movement of data and
solving the problems of a large-scale shared distributed network.

But as the use of the Internet grew rapidly in the late 1980s and literally
exploded when the Web became mainstream in 1994 security and encryption of
network traffic became a very important problem to solve.  Once we started
using the internet to conduct commerce and credit cards and bank account
numbers were being routinely sent across the network, security and encryption
became essential.   And when we started using wireless technologies like WiFi
security became essential to even the simplest uses of the Internet.

\index{physical security}
There are generally two approaches to securing network activity.  The first
makes sure that all of the network hardware (routers and links) are in
physically secure locations so it is not possible to sneak in and monitor
traffic while it is crossing the Internet.  This approach is not
practical given that there are hundreds of thousands of network routers that
are owned and operated by many different organizations.   While you might be
able to insure that some of the router operators adhered to strict security
procedures and policies, sooner or later a mistake will be made.  And when WiFi
was added to the mix and your packets went over radio waves, a network attacker
could just sit in a coffee shop and monitor packets as they passed through the
air.

\index{encrypt}
\index{decrypt}
With these limitations the only reasonable solution is to encrypt data within
your computer before it is sent across its first physical link and then decrypt
the data in the destination computer after it arrives.  Using this approach, we
assume that the attacker can see all of the packets that you send but since we
have effective encryption, they cannot decrypt the data that they have
captured.   The encryption also makes sure that there is no way to alter the
data you are sending while it is crossing the Internet.

Two Kinds of Secrets
--------------------

\index{shared secret}
The approach to encrypting messages so that while everyone might see the
encrypted message while it is being transported but only the correct receiver
of the message can decrypt the message is well understood.   The traditional
way to encrypt transmissions was using a secret that only the sending and
receiving parties know.  With the secret it is easy to decrypt the received
data but if you received the data without possessing the secret, it would be
difficult (effectively impossible) to decrypt the message.

![Shared Secrets](sketchnote/Shared_Secret)

The shared secret approach could be used in a few situations in the early
internet where two people could send encrypted e-mail to each other by calling
the other person on the phone and giving them the decryption secret.   This
worked but could not scale to situations where a company would have
millions of customers and could not afford to make a phone call to each
customer to establish a shared secret before they could make a purchase.

It might seem like a good idea to distribute the shared secrets over the
Internet, but if we assume that the attackers are monitoring and capturing all
network traffic they would also capture the unencrypted message that contained
the shared secret.   At that point it would be trivial for the attacker to also
use the shared secret to decrypt a message.  And even worst, the attacker could
intercept a message, delay it, then decrypt it, change and re-encrypt it and
send the modified message back on its way.  The receiving computer would
decrypt the message and never know if it had been modified while in-transit by
an attacker.

So shared secrets clearly would not work to solve the problem of securing
network traffic between trillions of pairs of networked computers.

\index{asymetric key}
\index{private key}
\index{public key}
The solution to this problem came in the 1970's when the concept of asymmetric
key encryption was discovered.  The idea of asymmetric key encryption is that
one key is used to encrypt the message and another key is used to decrypted the
message.  The computer that will be receiving the encrypted data chooses both
then encryption key and decryption key.    Then the encryption key is sent to
the computer that will be sending the data.   The sending computer encrypts the
data and sends it across the network.  The receiving computer uses the
decryption key to decrypt the data.

![Asymmetric Keys](sketchnote/Shared_vs_Asymmetric)

We call the encryption key the "public" key because it is can be widely shared.
We call the decryption key the "private" key because it never leaves the
computer where it was created.  Another name for asymmetric keys is a
public-private keys.

The whole process is designed so that if an attacker has the public key (which
was sent unencrypted) and the encrypted text, it is virtually impossible to
decrypt the encrypted data.  There is a lot of math with large prime numbers
that make it hard to guess the private key from the public key and encrypted
data.

So with the advent of public-private key technology, the only question was how
to apply it in our network model.

![Asymmetric Keys](sketchnote/Asymmetric_keys)

Secure Sockets Layer (SSL)
--------------------------

\index{Secure Socket Layer}
\index{SSL}
\index{TLS}
\index{Transport Layer Security}
Since we were adding network security nearly 20 years after the Internet
protocols were developed, it was important not to break the existing internet
protocols or architecture when security was added.

The solution was to add an optional partial layer between the Transport layer
and the Application layer.   We called this partial layer the Secure Sockets
Layer (SSL) or Transport Layer Security (TLS).

When an application would request that the Transport layer make a connection to
a remote host, it could request that the connection either be unencrypted or
encrypted.  If an encrypted connection was requested, the transport layer would
encrypt the data before breaking the stream into packets.  This meant that all
of the rest of the Transport Layer, Internetwork Layer, and Physical layers
perform exactly the same whether the packets are encrypted or non-encrypted.
And the applications making the connections were spared the details of how
encryption and decryption worked.

Since encryption was a simple an transparent addition to the Transport layer,
there was no need to change routers that operate at the Internetwork and
Link layers.  And there was no need to change any Link layer hardware to make
encryption work.  Also applications did not need to be modified except to
request that a connection be encrypted when appropriate.

Encrypting Web Browser Traffic
------------------------------

\index{https}
Since web browser and web servers operate at the Application layer we barely
notice when we are using encrypted or unencrypted connections.  Web browsers
use the URL convention of replacing "http:" with "https:" to indicate that the
browser is to communicate with the web server using the secure transport layer
instead of the unencrypted transport layer.

For a while, some web applications did not use secure HTTP on all pages.
There is a small overhead in setting up the https connections and a small cost
to encrypt and decrypt the data that is being sent.  Since https was slightly
more costly, for a while it was used only for pages that contained passwords,
bank account numbers, or other sensitive data.

But over time as networks have become faster and the https implementations have
gotten much more efficient, there is a trend toward encrypting all web server
interactions whenever you are interacting with a web server where you have an
account.

Certificates and Certificate Authorities
----------------------------------------

\index{CA}
\index{Certificate Authority}
While the public/private key encryption works to allow the
distribution of encryption keys across insecure networks and then using those
keys to encrypt transmissions, there is still a problem of knowing if the
public key that you have received when you connected to a server is really from
the organization you expect it to be.

We need to deal with the problem where you think you are connecting wo
www.amazon.com but a rogue computer intercepts your traffic claiming to be
www.amazon.com and giving you a public key to use for encrypting your traffic.
If your web browser trusts the key, it will use the rogue computer's public key
to encrypt your banking information and send it to the rogue computer.  Since
the rogue computer gave you the public key, it also has the private key and is
able to decrypt and abscond with your banking information.

\index{digital signatures}
\index{signed key}
So your computer needs to know who the key is actually coming from.   This is
achieved by sending you a public key that is digitally signed by a Certificate
Authority (CA).  When your computer or browser is initially installed it knows
about a number of well-known certificate authorities. If your browser is given
a public key that is signed by one of the well-known certificate authorities,
it trusts the key and uses it to encrypt and send your data.  If your computer
receives a public key that is not signed by one of its trusted certificate
authorities, it will warn you before sending your data using
the key.

If you see a warning messages about an untrusted
certificate, you should probably say 'no' and figure out why your network
traffic is not being routed to the server that you think it is going to before
sending any sensitive data.

Summary
-------

Since the Internet was nearly 20 years old before we needed broadly deployed
security, we needed to find a way to add security to the already existing four
layer model.  The perfect place to add security was as an option in the
Transport Layer.   This is why we call secure connections on the Internet
"Secure Sockets Layer" (SSL) or "Transport Layer Security" (TLS).

The invention of public-private key encryption was well-timed in that it solved
the key distribution problem of shared-secret encryption approaches.  With
Public-private keys, the public encryption key can be routinely shared across
insecure media.  This means we can use an un-encrypted connection to exchange
data and upgrade the connection to a secure connection.

By inserting the secure layer at the top of the Transport Layer we were able to
avoid changing the Application, Internetwork, and Link layers to make it
possible to easily secure any transport layer connection.  This approach
insures that all data being sent across a connection is encrypted before it
leaves your computer.  Given that many of us use wireless connections like WiFi
which are easily monitored by attackers, it is a good idea to encrypt data
before it is sent across WiFi.

Browsers support secure connections by changing the prefix on the URL
from "http:" to "https:".  By keeping an eye on the URL, end users can make
sure to never send sensitive data across insecure connections.

In order to make sure that you can trust the public key that has been provided
to you by the server, there are a series of trusted Certificate Authorities
that will sign public keys to give you an assurance that the key you received
is indeed from the organization you expect it to be.

The design of the secure transport layer provides a secure and yet easy to use
mechanism for secure communications across the Internet at a scale of trillions
of pairs of computers interacting.

*Draft - Copyright All Rights Reserved - Charles R. Severance.
Please do not reproduce or redistribute.*
